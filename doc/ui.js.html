<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: ui.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: ui.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>import {clearURLParams, hsbToRgb, isTouchDevice, updateURLParams} from './utils.js';
import {initMouseHandlers, registerMouseEventHandlers, unregisterMouseEventHandlers} from "./mouseEventHandlers";
import {initTouchHandlers, registerTouchEventHandlers, unregisterTouchEventHandlers} from "./touchEventHandlers";
import {JuliaRenderer} from "./juliaRenderer";

/**
 * @module UI
 * @author Radim Brnka
 * @description Contains code to manage the UI (header interactions, buttons, infoText update, etc.).
 */

/**
 * Debug mode. False for prod
 * @type {boolean}
 */
export const DEBUG_MODE = true;

let canvas;
let fractalApp;
// 0..Mandelbrot, 1..Julia
export const MODE_MANDELBROT = 0;
export const MODE_JULIA = 1;
let fractalMode = MODE_MANDELBROT;
let mandelbrotSwitch;
let juliaSwitch;

let headerMinimizeTimeout = null;
let uiInitialized = false;
let headerToggled = false;

let demoActive = false;
let travelToPresetActive = false;
let juliaDemoTime = 0;
let activeJuliaDiveIndex = -1;
let activePresetIndex = -1;
let resizeTimeout;

let header;
let handle;
let infoLabel;
let infoText;
let resetButton;
let randomizeColorsButton;
let screenshotButton;
let demoButton;
let presetButtons = [];
let diveButtons = [];
let allButtons = [];

// Julia sliders
let realSlider;
let imagSlider;
let realSliderValue;
let imagSliderValue;
let lastSliderUpdate = 0; // Tracks the last time the sliders were updated
const sliderUpdateThrottleLimit = 10; // Throttle limit in milliseconds
const JULIA_HOTKEY_C_STEP = 0.0005; // Smooth stepping: step size
const JULIA_HOTKEY_C_SMOOTH_STEP = 0.1; // Super smooth stepping multiplier (SHIFT)
const JULIA_HOTKEY_C_SPEED = 50; // Smooth stepping: animation delay

let lastInfoUpdate = 0; // Tracks the last time the sliders were updated
const infoUpdateThrottleLimit = 10; // Throttle limit in milliseconds


let currentMandelbrotDemoPresetIndex = 1; // Keep track of the current preset
let currentDemoAnimationFrame = null;
let rotationAnimationFrame = null; // For hotkey rotation only
let activeTimers = []; // Store all active demo timers

function switchFractalMode(mode) {
    clearURLParams();

    const path = mode === MODE_JULIA ? '#julia' : '';
    window.location.hash = path; // Update URL hash
    window.location.reload();
}

export function isJuliaMode() {
    return fractalMode === MODE_JULIA;
}

export function setDefaultPresetButtonActive() {
    resetPresetAndDiveButtonStates();
    activePresetIndex = 0;
    presetButtons[0].classList.add('active');
}

export function enableJuliaMode() {
    fractalMode = MODE_JULIA;
    juliaSwitch.classList.add('active');
    mandelbrotSwitch.classList.remove('active');
}

function stopAnimationMode() {
    // if (!demoActive || !travelToPresetActive) return;
    //
    // if (travelToPresetActive) {
    //     console.log('Travel to preset interrupted.');
    //     currentMandelbrotDemoPresetIndex = -1;
    //     activePresetIndex = -1;
    // }
    //
    // if (demoActive) {
    //     demoActive = false;
    // }


    // activeJuliaDiveIndex = -1;
    //
    // console.log("Stopping demo");
    //
    // demoActive = false;
    // currentMandelbrotDemoPresetIndex = 0;
    // fractalApp.stopCurrentNonColorAnimation();
    demoButton.innerText = "Demo";
    demoButton.classList.remove('active');
    // // if (travelToPresetActive) {
    // //     resetPresetAndDiveButtons();
    // // } else {
    // //     activePresetIndex = -1;
    // // }
    //
    if (isTouchDevice()) {
        console.log("Registering touch events");
        registerTouchEventHandlers();
    } else {
        registerMouseEventHandlers();
    }
    //
    if (isJuliaMode()) {
        if (currentDemoAnimationFrame !== null) {
            cancelAnimationFrame(currentDemoAnimationFrame);
            currentDemoAnimationFrame = null;
        }
        enableJuliaSliders();
    } else {
        fractalApp.stopCurrentNonColorAnimation();
    }
    // setTimeout(() => {
    //     updateInfo();
    // }, 150);
}

function initAnimationMode(demoMode = false) {
    console.log('initAnimationMode ' + fractalMode);

    if (demoMode) {
        demoActive = true;
    } else {
        travelToPresetActive = true;
    }

    // demoActive = true;
    //
    // resetPresetAndDiveButtons();
    demoButton.innerText = "Stop";
    demoButton.classList.add('active');
    //
    // Unregister control events
    if (isTouchDevice()) {
        console.log("Unregistering touch events");
        unregisterTouchEventHandlers();
    } else {
        unregisterMouseEventHandlers();
    }

    if (isJuliaMode()) {
        disableJuliaSliders();
    }

    clearURLParams();
}

async function toggleDemo() {

    if (demoActive) {
        demoActive = false;
        resetPresetAndDiveButtonStates();
        stopRotationAnimation();
        stopAnimationMode();
        return;
    }

    if (travelToPresetActive) {
        travelToPresetActive = false;
        resetPresetAndDiveButtonStates();
        stopRotationAnimation();
        stopAnimationMode();
        return;
    }

    if (fractalMode === MODE_MANDELBROT) {
        const presets = fractalApp.PRESETS;
        if (!presets || presets.length === 0) {
            console.warn('No presets defined for Mandelbrot mode ');
            return;
        }
        await startMandelbrotDemo();
    } else if (fractalMode === MODE_JULIA) {
        startJuliaDemo();
    } else {
        console.warn('No demo defined for mode ' + fractalMode);
    }
}

/**
 * Helper function that returns a Promise that resolves after ms milliseconds.
 */
function delay(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
}

/**
 * Starts the Mandelbrot demo using async/await.
 * It animates through the presets (from fractalApp.PRESETS) by waiting for the
 * preset animation to finish and then pausing for 3500ms before moving on.
 */
async function startMandelbrotDemo() {
    if (demoActive) return;
    initAnimationMode(true);

    const presets = fractalApp.PRESETS.slice();

    // Continue cycling through presets while demo is active.
    while (demoActive) {
        const currentPreset = presets[currentMandelbrotDemoPresetIndex];
        console.log("Animating to preset:", currentPreset);

        // Animate to the current preset.
        await fractalApp.animateTravelToPresetWithRandomRotation(currentPreset, 1000, 500, 5000);

        // Wait 3500ms after the animation completes.
        await delay(3500);

        // Update index to move to the next preset.
        currentMandelbrotDemoPresetIndex = (currentMandelbrotDemoPresetIndex + 1) % presets.length;
    }

    // When demoActive is false, reset the fractal.
    resetPresetAndDiveButtonStates();
    stopRotationAnimation();
    stopAnimationMode();
}

function startJuliaDive(dives, index) {
    if (index === activeJuliaDiveIndex) {
        console.log(`%c startJuliaDive: %c Dive ${index} already in progress. Skipping.`, 'color: #bada55', 'color: #fff');
        return;
    }

    stopAnimationMode();
    resetPresetAndDiveButtonStates();
    activePresetIndex = -1;
    activeJuliaDiveIndex = index;
    diveButtons[index].classList.add('active');
    const dive = dives[index];

    // if (demoActive) return;

    // Validate configuration:
    if (dive.cxDirection &lt; 0 &amp;&amp; dive.endC[0] >= dive.startC[0]) {
        console.error("For negative cxDirection, endC[0] must be lower than startC[0].");
        return;
    } else if (dive.cxDirection > 0 &amp;&amp; dive.endC[0] &lt;= dive.startC[0]) {
        console.error("For positive cxDirection, endC[0] must be higher than startC[0].");
        return;
    }
    if (dive.cyDirection &lt; 0 &amp;&amp; dive.endC[1] >= dive.startC[1]) {
        console.error("For negative cyDirection, endC[1] must be lower than startC[1].");
        return;
    } else if (dive.cyDirection > 0 &amp;&amp; dive.endC[1] &lt;= dive.startC[1]) {
        console.error("For positive cyDirection, endC[1] must be higher than startC[1].");
        return;
    }

    if (!dive.phases) {
        console.warn("Phases are not defined, setting to default order.");
        dive.phases = [1, 2, 3, 4];
    }

    initAnimationMode();

    //if (DEBUG_MODE) dive.step *= 10;

    let phase = dive.phases[0] || 1;
    let phaseIndex = 0; // TODO implement phase ordering

    // Transition to the initial preset first.
    fractalApp.animateTravelToPreset({
        pan: dive.pan, c: dive.startC.slice(), // copy initial c
        zoom: dive.zoom, rotation: dive.rotation
    }, 500, () => {
        function animate() {
            const step = dive.step;
            // Phase 1: Animate cx (real part) toward endC[0]
            if (phase === 1) {
                fractalApp.c[0] += dive.cxDirection * step;
                if ((dive.cxDirection &lt; 0 &amp;&amp; fractalApp.c[0] &lt;= dive.endC[0]) || (dive.cxDirection > 0 &amp;&amp; fractalApp.c[0] >= dive.endC[0])) {
                    fractalApp.c[0] = dive.endC[0];
                    phase = 2;
                }
            }
            // Phase 2: Animate cy (imaginary part) toward endC[1]
            else if (phase === 2) {
                fractalApp.c[1] += dive.cyDirection * step;
                if ((dive.cyDirection &lt; 0 &amp;&amp; fractalApp.c[1] &lt;= dive.endC[1]) || (dive.cyDirection > 0 &amp;&amp; fractalApp.c[1] >= dive.endC[1])) {
                    fractalApp.c[1] = dive.endC[1];
                    phase = 3;
                }
            }
            // Phase 3: Animate cx back toward startC[0]
            else if (phase === 3) {
                fractalApp.c[0] -= dive.cxDirection * step;
                if ((dive.cxDirection &lt; 0 &amp;&amp; fractalApp.c[0] >= dive.startC[0]) || (dive.cxDirection > 0 &amp;&amp; fractalApp.c[0] &lt;= dive.startC[0])) {
                    fractalApp.c[0] = dive.startC[0];
                    phase = 4;
                }
            }
            // Phase 4: Animate cy back toward startC[1]
            else if (phase === 4) {
                fractalApp.c[1] -= dive.cyDirection * step;
                if ((dive.cyDirection &lt; 0 &amp;&amp; fractalApp.c[1] >= dive.startC[1]) || (dive.cyDirection > 0 &amp;&amp; fractalApp.c[1] &lt;= dive.startC[1])) {
                    fractalApp.c[1] = dive.startC[1];
                    phase = 1; // Loop back to start phase.
                }
            }

            fractalApp.draw();
            currentDemoAnimationFrame = requestAnimationFrame(animate);
            updateInfo(true);
            updateJuliaSliders();
        }

        animate();
    });
}

function startJuliaDemo() {
    if (demoActive) return;

    initAnimationMode(true);

    function animate() {
        fractalApp.c = [((Math.sin(juliaDemoTime) + 1) / 2) * 1.5 - 1,   // Oscillates between -1 and 0.5
            ((Math.cos(juliaDemoTime) + 1) / 2) * 1.4 - 0.7    // Oscillates between -0.7 and 0.7
        ];
        fractalApp.rotation += 0.0001;
        fractalApp.draw();
        juliaDemoTime += 0.0005;

        currentDemoAnimationFrame = requestAnimationFrame(animate);
        updateInfo(true);
        updateJuliaSliders();
    }

    fractalApp.animatePanZoomRotate(fractalApp.DEFAULT_PAN.slice(), fractalApp.DEFAULT_ZOOM, fractalApp.DEFAULT_ROTATION, 500, juliaDemoTime > 0 ? animate : () => {
        fractalApp.animateToC([-0.25, 0.7], 500, animate);
    });
}

function stopRotationAnimation() {
    if (rotationAnimationFrame !== null) {
        cancelAnimationFrame(rotationAnimationFrame);
        rotationAnimationFrame = null;
    }
}

function resetSliders() {
    realSlider.value = parseFloat(fractalApp.c[0].toFixed(2));
    imagSlider.value = parseFloat(fractalApp.c[1].toFixed(2));
    realSliderValue.innerText = realSlider.value;
    imagSliderValue.innerText = imagSlider.value + 'i';
    juliaDemoTime = 0;
}

function onTravelToPresetFinished() {
    console.log(`%c onTravelToPresetFinished: %c Travel to preset ${activePresetIndex} complete`, 'color: #bada55', 'color: #fff');

    stopAnimationMode();
    updateURLParams(fractalMode, fractalApp.pan[0], fractalApp.pan[1], fractalApp.zoom, fractalApp.rotation, fractalApp.c ? fractalApp.c[0] : null, fractalApp.c ? fractalApp.c[1] : null);
}

async function travelToPreset(presets, index) {
    if (travelToPresetActive) {
        console.log(`%c travelToPreset: %c Travel to preset ${index} requested, active travel in progress, interrupting...`, 'color: #bada55', 'color: #fff');
    }

    if (index === activePresetIndex) {
        console.log(`%c travelToPreset: %c Already on preset ${index}, skipping.`, 'color: #bada55', 'color: #fff');
        return;
    }

    console.log(`%c travelToPreset: %c Executing travel to preset ${index}`, 'color: #bada55', 'color: #fff');

    resetPresetAndDiveButtonStates();
    initAnimationMode();

    presetButtons[index].classList.add('active');

    if (isJuliaMode()) {
        juliaDemoTime = 0;
        await fractalApp.animateTravelToPreset(presets[index], 750);
        onTravelToPresetFinished();
        activePresetIndex = index;
    } else {
        await fractalApp.animateTravelToPreset(presets[index]);
        onTravelToPresetFinished();
        activePresetIndex = index;
    }
}

function initDebugMode() {
    console.warn('DEBUG MODE ENABLED');

    infoLabel.style.height = '100px';

    const debugInfo = document.getElementById('debugInfo');
    debugInfo.style.display = 'block';
    const dpr = window.devicePixelRatio;

    const {width, height} = canvas.getBoundingClientRect();
    const displayWidth = Math.round(width * dpr);
    const displayHeight = Math.round(height * dpr);
    (function update() {
        debugInfo.innerText = `WINDOW: ${window.innerWidth}x${window.innerHeight} (dpr: ${window.devicePixelRatio})
        CANVAS: ${canvas.width}x${canvas.height}, aspect: ${(canvas.width / canvas.height).toFixed(2)} 
        BoundingRect: ${width}x${height}, display W/H: ${displayWidth}x${displayHeight}`;
        requestAnimationFrame(update);
    })();

    debugInfo.addEventListener('click', () => {
        console.log(debugInfo.innerText);
    });

    toggleDebugLines();
}

export function toggleDebugLines() {
    const verticalLine = document.getElementById('verticalLine');
    const horizontalLine = document.getElementById('horizontalLine');

    if (verticalLine.style.display === 'block' &amp;&amp; horizontalLine.style.display === 'block') {
        verticalLine.style.display = 'none';
        horizontalLine.style.display = 'none';
    } else {
        verticalLine.style.display = 'block';
        horizontalLine.style.display = 'block';
    }
}

export function resetPresetAndDiveButtonStates() {
    console.log(`%c resetPresetAndDiveButtonStates: %c Button states reset.`, 'color: #bada55', 'color: #fff');
    presetButtons.concat(diveButtons).forEach(b => b.classList.remove('active'));
}

/**
 * This needs to happen on any fractal change
 */
export function resetActivePresetIndex() {
    activePresetIndex = -1;
}

function takeScreenshot() {
    // Ensure the fractal is fully rendered before taking a screenshot
    fractalApp.draw();

    // Create an offscreen canvas for watermarking
    const offscreenCanvas = document.createElement('canvas');
    offscreenCanvas.width = canvas.width;
    offscreenCanvas.height = canvas.height;
    const ctx = offscreenCanvas.getContext('2d');

    if (!ctx) {
        console.error('Unable to get 2D context for the canvas.');
        return;
    }

    // Copy the fractal canvas content to the offscreen canvas
    ctx.drawImage(canvas, 0, 0);

    // Define the watermark text and style
    let watermarkText = `Created by Synaptory Fractal Traveler, `;
    watermarkText += (fractalMode === MODE_MANDELBROT ? `(Mandelbrot: p=[${fractalApp.pan[0].toFixed(6)}, ${fractalApp.pan[1].toFixed(6)}i], Z=${fractalApp.zoom.toFixed(6)})` : `(Julia: c=[${fractalApp.c[0]}, ${fractalApp.c[1]}i], p=[${fractalApp.pan[0].toFixed(6)}, ${fractalApp.pan[1].toFixed(6)}], Z=${fractalApp.zoom.toFixed(6)})`);
    const fontSize = 12;
    const padding = 6;
    const borderWidth = 1;

    ctx.font = `${fontSize}px sans-serif`;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';

    // Measure the text width and calculate the rectangle size
    const textWidth = ctx.measureText(watermarkText).width;
    const rectWidth = textWidth + padding * 2 + borderWidth * 2;
    const rectHeight = fontSize + padding * 2 + borderWidth * 2;

    // Position the rectangle in the bottom-right corner
    const x = offscreenCanvas.width - rectWidth - padding;
    const y = offscreenCanvas.height - rectHeight - padding;

    // Draw the semi-transparent black background
    ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
    ctx.fillRect(x, y, rectWidth, rectHeight);

    // Draw the border
    const palette = fractalApp.colorPalette;
    ctx.strokeStyle = `rgba(${Math.floor(palette[0] * 200)}, ${Math.floor(palette[1] * 200)}, ${Math.floor(palette[2] * 200)}, 0.3)`;
    ctx.lineWidth = borderWidth;
    ctx.strokeRect(x, y, rectWidth, rectHeight);

    // Draw the text centered within the rectangle
    const brightnessFactor = 1.9;
    const adjustChannel = (value) => Math.min(255, Math.floor(value * 255 * brightnessFactor));
    const textX = x + rectWidth / 2;
    const textY = y + rectHeight / 2;
    ctx.fillStyle = `rgb(${adjustChannel(palette[0])}, ${adjustChannel(palette[1])}, ${adjustChannel(palette[2])}, 0.8)`;
    ctx.fillText(watermarkText, textX, textY);

    // Create a temporary link for downloading the image
    const link = document.createElement('a');

    // Generate a filename based on the current timestamp
    const generateFilename = () => {
        const now = new Date();
        const pad = (n) => String(n).padStart(2, '0');
        return `fractal-${now.getFullYear()}-${pad(now.getMonth() + 1)}-${pad(now.getDate())}_${pad(now.getHours())}-${pad(now.getMinutes())}-${pad(now.getSeconds())}.png`;
    };

    // Set the download attributes
    link.setAttribute('download', generateFilename());
    link.setAttribute('href', offscreenCanvas.toDataURL("image/jpeg", 0.95));
    link.click();
}

async function randomizeColors() {
    // Generate a bright random color palette
    // Generate colors with better separation and higher brightness
    const hue = Math.random(); // Hue determines the "base color" (red, green, blue, etc.)
    const saturation = Math.random() * 0.5 + 0.5; // Ensure higher saturation (more vivid colors)
    const brightness = Math.random() * 0.5 + 0.5; // Ensure higher brightness

    // Convert HSB/HSV to RGB
    const newPalette = hsbToRgb(hue, saturation, brightness);

    await fractalApp.animateColorPaletteTransition(newPalette, 250, updateColorTheme); // Update app colors
}

function initHeaderEvents() {

    header.addEventListener('pointerenter', () => {
        if (headerMinimizeTimeout) {
            clearTimeout(headerMinimizeTimeout);
            headerMinimizeTimeout = null;
        }
        handle.style.display = "none";
        header.classList.remove('minimized');
    });

    header.addEventListener('pointerleave', () => {
        // Only minimize if it hasn't been toggled manually
        if (!headerToggled &amp;&amp; !DEBUG_MODE) {
            headerMinimizeTimeout = setTimeout(() => {
                header.classList.add('minimized');
                handle.style.display = "block";
                headerMinimizeTimeout = null;
            }, 1000);
        }
    });

    // Toggle header state when header is clicked/tapped and stop auto-close
    handle.addEventListener('pointerdown', (event) => {
        if (!headerToggled) {
            header.classList.remove('minimized');
            handle.style.display = "none";
        } else {
            header.classList.add('minimized');
            handle.style.display = "block";
        }

        headerToggled = !headerToggled;

        if (headerMinimizeTimeout) {
            clearTimeout(headerMinimizeTimeout);
            headerMinimizeTimeout = null;
        }
    });

    // When user clicks/taps outside of the header
    canvas.addEventListener('pointerdown', () => {
        if (DEBUG_MODE) return;

        header.classList.add('minimized');
        handle.style.display = "block";
        headerToggled = false;
    });
}

function initControlButtonEvents() {

    resetButton.addEventListener('click', () => {
        switchFractalMode(fractalMode);
    });

    randomizeColorsButton.addEventListener('click', () => {
        randomizeColors().then(() => {

        });
    });

    demoButton.addEventListener('click', () => {
        toggleDemo();
    });

    screenshotButton.addEventListener('click', () => {
        takeScreenshot();
    });

}

function initPresetButtonEvents() {
    const presetBlock = document.getElementById('presets');
    presetBlock.innerHTML = 'Presets: ';

    presetButtons = [];

    const presets = fractalApp.PRESETS.slice();
    presets.forEach((preset, index) => {
        const btn = document.createElement('button');
        btn.id = 'preset' + (index);
        btn.className = 'preset';
        btn.textContent = (index).toString();
        btn.addEventListener('click', () => {
            travelToPreset(presets, index);
        });

        presetBlock.appendChild(btn);
        presetButtons.push(btn);
        presetButtons[0].classList.add('active');
    });
}

/**
 * Inits behavior common for all buttons
 */
function initCommonButtonEvents() {
    allButtons = diveButtons.concat(presetButtons);
    allButtons.push(resetButton, randomizeColorsButton, screenshotButton, demoButton);

    allButtons.forEach((btn) => {
        btn.addEventListener('mouseleave', () => {
            btn.blur();
        });

        btn.addEventListener('mouseup', () => {
            btn.blur();
        });
    });
}

function initDives() {
    if (isJuliaMode()) {
        const diveBlock = document.getElementById('dives');
        diveBlock.innerHTML = 'Dives: ';

        diveButtons = [];

        const dives = fractalApp.DIVES.slice();
        dives.forEach((dive, index) => {
            const btn = document.createElement('button');
            btn.id = 'dive' + (index);
            btn.className = 'dive';
            btn.textContent = (index).toString();
            btn.addEventListener('click', () => {
                startJuliaDive(dives, index);
            });

            diveBlock.appendChild(btn);
            diveButtons.push(btn);
        });

        diveBlock.style.display = 'block';
    }
}

function initFractalSwitchRadios() {
    mandelbrotSwitch.addEventListener('click', (event) => {
        if (isJuliaMode()) switchFractalMode(MODE_MANDELBROT);
    });

    juliaSwitch.addEventListener('click', (event) => {
        if (!isJuliaMode()) switchFractalMode(MODE_JULIA);
    });
}

function initSliders() {
    resetSliders();

    // Update `c` dynamically when sliders are moved
    realSlider.addEventListener('input', () => {
        fractalApp.c[0] = parseFloat(realSlider.value);
        realSliderValue.innerText = fractalApp.c[0].toFixed(2);
        fractalApp.draw();
        updateInfo();
        clearURLParams();
        resetPresetAndDiveButtonStates();
        juliaDemoTime = 0;
    });

    imagSlider.addEventListener('input', () => {
        fractalApp.c[1] = parseFloat(imagSlider.value);
        imagSliderValue.innerText = fractalApp.c[1].toFixed(2) + 'i';
        fractalApp.draw();
        updateInfo();
        clearURLParams();
        resetPresetAndDiveButtonStates();
        juliaDemoTime = 0;
    });

    let sliderContainer = document.getElementById('sliders');
    sliderContainer.style.display = 'flex';
}

function initWindowEvents() {
    window.addEventListener('resize', () => {
        clearTimeout(resizeTimeout);
        resizeTimeout = setTimeout(() => {
            fractalApp.resizeCanvas(); // Adjust canvas dimensions
        }, 200); // Adjust delay as needed
    });
}

function initInfoText() {
    infoText.addEventListener('click', () => {
        let textarea = document.getElementById("infoText");
        let text = `{pan: [${fractalApp.pan}], rotation: ${fractalApp.rotation}, zoom: ${fractalApp.zoom}`;
        text += isJuliaMode() ? `, c: [${fractalApp.c}]}` : `}`;
        navigator.clipboard.writeText(text).then(function () {
            textarea.innerText = 'Copied to clipboard!';
        }, function (err) {
            console.error('Not copied to clipboard! ' + err.toString());
        });
    });
}

function initHotkeys() {
    document.addEventListener("keydown", (event) => {

        const disallowedHotkeys = ["ArrowLeft", "ArrowRight", "ArrowUp", "ArrowDown", "Space"];

        if (demoActive &amp;&amp; disallowedHotkeys.includes(event.code)) return;

        const rotationSpeed = event.shiftKey ? 0.01 : 0.1;
        const mandelbrotPanSpeed = event.shiftKey ? 0.01 : 0.1;

        /**
         * https://www.freecodecamp.org/news/javascript-keycode-list-keypress-event-key-codes/
         */
        switch (event.code) {
            case 'KeyQ': // Rotation counter-clockwise
                if (rotationAnimationFrame !== null) {
                    stopRotationAnimation();
                } else {
                    (function animate() {
                        fractalApp.rotation = (fractalApp.rotation - rotationSpeed + 2 * Math.PI) % (2 * Math.PI); // Normalize rotation
                        fractalApp.draw();
                        rotationAnimationFrame = requestAnimationFrame(animate);
                        updateInfo(true);
                    })();
                }
                break;

            case 'KeyW':  // Rotation clockwise
                if (rotationAnimationFrame !== null) {
                    stopRotationAnimation();
                } else {
                    (function animate() {
                        fractalApp.rotation = (fractalApp.rotation + rotationSpeed + 2 * Math.PI) % (2 * Math.PI); // Normalize rotation
                        fractalApp.draw();
                        rotationAnimationFrame = requestAnimationFrame(animate);
                        updateInfo(true);
                    })();
                }
                break;


            case 'KeyE': // Debug lines
                toggleDebugLines();
                break;

            case 'KeyR': // Reset
                if (event.shiftKey) switchFractalMode(fractalMode);
                break;

            case 'KeyT': // Random colors
                if (event.altKey) {
                    fractalApp.colorPalette = fractalApp.DEFAULT_PALETTE;
                    fractalApp.draw();
                    updateColorTheme();
                    return;
                }
                if (event.shiftKey) {
                    console.log(" animating colors  " + fractalApp.currentColorAnimationFrame);
                    if (fractalApp.currentColorAnimationFrame !== null) {
                        console.log("stopping animating colors");
                        fractalApp.stopCurrentColorAnimation();
                    } else {
                        console.log("starting animating colors");
                        fractalApp.animateFullColorSpaceCycle(15000);
                    }
                } else {
                    randomizeColors();
                }
                break;

            case 'KeyA': // Forced resize
                console.log("Resizing canvas (forced)");
                fractalApp.resizeCanvas();
                break;

            case 'KeyS': // Screenshot
                if (event.shiftKey) takeScreenshot();
                break;

            case 'KeyD': // Start/stop demo
                toggleDemo();
                break;

            case "ArrowLeft": // Julia cx smooth down
                // TODO refactor
                // if (isJuliaMode()) {
                //     // Calculate step size.
                //     let step = JULIA_HOTKEY_C_STEP * (event.shiftKey ? JULIA_HOTKEY_C_SMOOTH_STEP : 1);
                //     // Base delta for left arrow in unrotated space: move left by step.
                //     let dx = -step;
                //     let dy = 0;
                //     // Get current rotation.
                //     let r = fractalApp.rotation;
                //     // Rotate the delta by the current rotation so that movement follows the rotated axes.
                //     // (This rotates the vector [dx,dy] by angle r.)
                //     let deltaX = dx * Math.cos(r) - dy * Math.sin(r);
                //     let deltaY = dx * Math.sin(r) + dy * Math.cos(r);
                //     // Animate to the new c value.
                //     fractalApp.animateToC([ fractalApp.c[0] + deltaX, fractalApp.c[1] + deltaY ], JULIA_HOTKEY_C_SPEED);
                // } else {
                //     // For Mandelbrot pan, do a similar transformation:
                //     let step = mandelbrotPanSpeed * fractalApp.zoom;
                //     let r = fractalApp.rotation;
                //     let dx = -step, dy = 0;
                //     let deltaX = dx * Math.cos(r) - dy * Math.sin(r);
                //     let deltaY = dx * Math.sin(r) + dy * Math.cos(r);
                //     fractalApp.animatePan([ fractalApp.pan[0] + deltaX, fractalApp.pan[1] + deltaY ], 50);
                // }
                if (event.ctrlKey || !isJuliaMode()) {
                    let step = mandelbrotPanSpeed * fractalApp.zoom;
                    let r = fractalApp.rotation;
                    let dx = -step, dy = 0;
                    let deltaX = dx * Math.cos(r) - dy * Math.sin(r);
                    let deltaY = dx * Math.sin(r) + dy * Math.cos(r);
                    fractalApp.animatePan([fractalApp.pan[0] + deltaX, fractalApp.pan[1] + deltaY], 50).then(() => {
                        resetPresetAndDiveButtonStates();
                        resetActivePresetIndex();
                    });
                } else {
                    fractalApp.animateToC([fractalApp.c[0] - JULIA_HOTKEY_C_STEP * (event.shiftKey ? JULIA_HOTKEY_C_SMOOTH_STEP : 1), fractalApp.c[1]], JULIA_HOTKEY_C_SPEED);
                }
                break;

            case "ArrowRight": // Julia cx smooth up
                if (event.ctrlKey || !isJuliaMode()) {
                    let step = mandelbrotPanSpeed * fractalApp.zoom;
                    let r = fractalApp.rotation;
                    let dx = step, dy = 0;
                    let deltaX = dx * Math.cos(r) - dy * Math.sin(r);
                    let deltaY = dx * Math.sin(r) + dy * Math.cos(r);
                    fractalApp.animatePan([fractalApp.pan[0] + deltaX, fractalApp.pan[1] + deltaY], 50).then(() => {
                        resetPresetAndDiveButtonStates();
                        resetActivePresetIndex();
                    });
                } else {
                    fractalApp.animateToC([fractalApp.c[0] + JULIA_HOTKEY_C_STEP * (event.shiftKey ? JULIA_HOTKEY_C_SMOOTH_STEP : 1), fractalApp.c[1]], JULIA_HOTKEY_C_SPEED);
                }
                break;

            case "ArrowUp": // Julia cy smooth up
                if (event.ctrlKey || !isJuliaMode()) {
                    let step = mandelbrotPanSpeed * fractalApp.zoom;
                    let r = fractalApp.rotation;
                    let dx = 0, dy = step;
                    let deltaX = dx * Math.cos(r) - dy * Math.sin(r);
                    let deltaY = dx * Math.sin(r) + dy * Math.cos(r);
                    fractalApp.animatePan([fractalApp.pan[0] + deltaX, fractalApp.pan[1] + deltaY], 50).then(() => {
                        resetPresetAndDiveButtonStates();
                        resetActivePresetIndex();
                    });
                } else {
                    fractalApp.animateToC([fractalApp.c[0], fractalApp.c[1] - JULIA_HOTKEY_C_STEP * (event.shiftKey ? JULIA_HOTKEY_C_SMOOTH_STEP : 1)], JULIA_HOTKEY_C_SPEED);
                }
                break; // Julia cy smooth down

            case "ArrowDown":
                if (event.ctrlKey || !isJuliaMode()) {
                    let step = mandelbrotPanSpeed * fractalApp.zoom;
                    let r = fractalApp.rotation;
                    let dx = 0, dy = -step;
                    let deltaX = dx * Math.cos(r) - dy * Math.sin(r);
                    let deltaY = dx * Math.sin(r) + dy * Math.cos(r);
                    fractalApp.animatePan([fractalApp.pan[0] + deltaX, fractalApp.pan[1] + deltaY], 50).then(() => {
                        resetPresetAndDiveButtonStates();
                        resetActivePresetIndex();
                    });
                } else {
                    fractalApp.animateToC([fractalApp.c[0], fractalApp.c[1] + JULIA_HOTKEY_C_STEP * (event.shiftKey ? JULIA_HOTKEY_C_SMOOTH_STEP : 1)], JULIA_HOTKEY_C_SPEED);
                }
                break;

            case "Space":
                const zoomFactor = event.shiftKey ? 1.1 : 0.9;
                const targetZoom = fractalApp.zoom * zoomFactor;

                if (targetZoom > fractalApp.MAX_ZOOM &amp;&amp; targetZoom &lt; fractalApp.MIN_ZOOM) {
                    fractalApp.animateZoom(fractalApp.zoom * zoomFactor, 20).then(() => {
                        resetPresetAndDiveButtonStates();
                        currentMandelbrotDemoPresetIndex = -1;
                        activePresetIndex = -1;
                    });
                }
                break;

            case "Enter":
                if (!headerToggled) {
                    header.classList.remove('minimized');
                    handle.style.display = "none";
                } else {
                    header.classList.add('minimized');
                    handle.style.display = "block";
                }

                headerToggled = !headerToggled;
                break;

            default:
                // Case nums:
                const match = event.code.match(/^(Digit|Numpad)([1-9])$/);
                if (match) {
                    console.log("Pressed:", event.code, "Number:", match[2]);

                    const index = match[2]; // match[2] contains the digit pressed
                    if (event.shiftKey &amp;&amp; isJuliaMode()) {
                        startJuliaDive(fractalApp.DIVES, index);
                    } else {
                        travelToPreset(fractalApp.PRESETS, index);
                    }
                }
                break;
        }
    });
}

/**
 * Initializes the UI and registers UI event handlers
 * @param fractalRenderer
 */
export function initUI(fractalRenderer) {
    if (uiInitialized) {
        console.warn("UI already initialized!");
        return;
    }

    fractalApp = fractalRenderer;
    canvas = fractalApp.canvas;

    // Element binding
    realSlider = document.getElementById('realSlider');
    realSliderValue = document.getElementById('realSliderValue');
    imagSlider = document.getElementById('imagSlider');
    imagSliderValue = document.getElementById('imagSliderValue');
    mandelbrotSwitch = document.getElementById('mandelbrotSwitch');
    juliaSwitch = document.getElementById('juliaSwitch');
    header = document.getElementById('headerContainer');
    handle = document.getElementById('handle'); // Header click icon
    infoLabel = document.getElementById('infoLabel');
    infoText = document.getElementById('infoText');
    resetButton = document.getElementById('reset');
    randomizeColorsButton = document.getElementById('randomize');
    screenshotButton = document.getElementById('screenshot');
    demoButton = document.getElementById('demo');

    if (fractalRenderer instanceof JuliaRenderer) {
        enableJuliaMode();
        initSliders();
        initDives();
        updateColorTheme([0.298, 0.298, 0.741]);
        // Darker backgrounds for Julia as it renders on white
        header.style.background = 'rgba(20, 20, 20, 0.8)';
        infoLabel.style.background = 'rgba(20, 20, 20, 0.8)';
    }

    initWindowEvents();
    initHeaderEvents();
    initControlButtonEvents();
    initPresetButtonEvents();
    initInfoText();
    initFractalSwitchRadios();
    initHotkeys();
    initCommonButtonEvents(); // After all dynamic buttons are set


    // Register control events
    if (isTouchDevice()) {
        initTouchHandlers(fractalApp);
    } else {
        initMouseHandlers(fractalApp);
    }

    if (DEBUG_MODE) {
        //initDebugMode();
    }

    uiInitialized = true;
}

/**
 * Updates color scheme
 * @param [palette] defaults to the fractal palette
 */
function updateColorTheme(palette) {
    palette ||= fractalApp.colorPalette.slice();

    const brightnessFactor = 1.9; // Increase brightness by 90%
    const adjustChannel = (value) => Math.min(255, Math.floor(value * 255 * brightnessFactor));

    const accentColor = `rgba(${adjustChannel(palette[0])}, ${adjustChannel(palette[1])}, ${adjustChannel(palette[2])}, 1)`;
    const bgColor = `rgba(${Math.floor(palette[0] * 200)}, ${Math.floor(palette[1] * 200)}, ${Math.floor(palette[2] * 200)}, 0.1)`; // Slightly dimmed for borders

    let root = document.querySelector(':root');
    root.style.setProperty('--bg-color', bgColor);
    root.style.setProperty('--accent-color', accentColor);
}

/**
 * Disable slider controls
 */
function disableJuliaSliders() {
    imagSlider.disabled = true;
    realSlider.disabled = true;

    realSlider.classList.add('thumbDisabled');
    imagSlider.classList.add('thumbDisabled');
}

/**
 * Enable slider controls
 */
function enableJuliaSliders() {
    imagSlider.disabled = false;
    realSlider.disabled = false;

    realSlider.classList.remove('thumbDisabled');
    imagSlider.classList.remove('thumbDisabled');
}

/**
 * Updates the bottom info bar
 * @param {boolean} [traveling] if inside animation
 */
export function updateInfo(traveling = false) {
    const now = performance.now();
    const timeSinceLastUpdate = now - lastInfoUpdate;

    if (timeSinceLastUpdate &lt; infoUpdateThrottleLimit) {
        return; // Skip update if called too soon
    }

    // Update the last update time
    lastInfoUpdate = now;

    if (!canvas || !fractalApp) {
        return;
    }

    let text = (demoActive ? ` [DEMO] ` : ``);

    const panX = fractalApp.pan[0] ?? 0;
    const panY = fractalApp.pan[1] ?? 0;

    if (fractalMode === MODE_MANDELBROT || (fractalMode === MODE_JULIA &amp;&amp; !demoActive)) {
        text += `p = [${panX.toFixed(DEBUG_MODE ? 12 : 6)}, ${panY.toFixed(DEBUG_MODE ? 12 : 6)}i] · `;
    }

    if (fractalMode === MODE_JULIA) {
        const cx = fractalApp.c[0] ?? 0;
        const cy = fractalApp.c[1] ?? 0;

        text += `c = [${cx.toFixed(DEBUG_MODE ? 12 : 2)}, ${cy.toFixed(DEBUG_MODE ? 12 : 2)}i] · `;
    }

    const currentZoom = fractalApp.zoom ?? 0;
    const currentRotation = (fractalApp.rotation * 180 / Math.PI) % 360;
    const normalizedRotation = currentRotation &lt; 0 ? currentRotation + 360 : currentRotation;
    text += `r = ${normalizedRotation.toFixed(0)}° · zoom = ${currentZoom.toFixed(6)}`;

    if (demoActive) {
        infoText.classList.add('demoActive');
    } else {
        infoText.classList.remove('demoActive');
    }

    infoText.textContent = text;
}

/**
 * Updates the real/imaginary sliders appropriately
 */
export function updateJuliaSliders() {
    const now = performance.now();
    const timeSinceLastUpdate = now - lastSliderUpdate;

    if (timeSinceLastUpdate &lt; sliderUpdateThrottleLimit) {
        return; // Skip update if called too soon
    }

    // Update the last update time
    lastSliderUpdate = now;
    realSliderValue.innerText = fractalApp.c[0].toFixed(2);
    imagSliderValue.innerText = fractalApp.c[1].toFixed(2) + 'i';
    realSlider.value = parseFloat(fractalApp.c[0].toFixed(2));
    imagSlider.value = parseFloat(fractalApp.c[1].toFixed(2));
}</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Modules</h3><ul><li><a href="module-Main.html">Main</a></li><li><a href="module-MouseEventhandlers.html">MouseEventhandlers</a></li><li><a href="module-TouchEventHandlers.html">TouchEventHandlers</a></li><li><a href="module-UI.html">UI</a></li><li><a href="module-Utils.html">Utils</a></li></ul><h3>Classes</h3><ul><li><a href="FractalRenderer.html">FractalRenderer</a></li><li><a href="JuliaRenderer.html">JuliaRenderer</a></li><li><a href="MandelbrotRenderer.html">MandelbrotRenderer</a></li></ul><h3><a href="global.html">Global</a></h3>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 4.0.4</a> on Fri Feb 14 2025 12:05:52 GMT+0100 (středoevropský standardní čas)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
